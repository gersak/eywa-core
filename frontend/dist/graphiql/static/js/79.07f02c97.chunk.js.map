{"version":3,"file":"static/js/79.07f02c97.chunk.js","mappings":"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","sources":["../node_modules/@graphiql/graphql-language-service/esm/utils/Range.js","../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs","../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs","../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs","../node_modules/graphql/language/predicates.mjs","../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs","../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs","../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs","../node_modules/graphql/jsutils/groupBy.mjs","../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs","../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs","../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs","../node_modules/graphql/utilities/sortValueNode.mjs","../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs","../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs","../node_modules/graphql/execution/values.mjs","../node_modules/graphql/execution/collectFields.mjs","../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs","../node_modules/graphql/validation/specifiedRules.mjs","../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs","../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs","../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs","../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs","../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs","../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs","../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs","../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs","../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs","../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs","../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs","../node_modules/graphql/validation/ValidationContext.mjs","../node_modules/graphql/validation/validate.mjs","../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","../node_modules/@graphiql/graphql-language-service/esm/utils/validateWithCustomRules.js","../node_modules/@graphiql/graphql-language-service/esm/interface/getDiagnostics.js","../node_modules/@graphiql/codemirror-graphql/esm/lint.js"],"sourcesContent":["export class Range {\n    constructor(start, end) {\n        this.containsPosition = (position) => {\n            if (this.start.line === position.line) {\n                return this.start.character <= position.character;\n            }\n            if (this.end.line === position.line) {\n                return this.end.character >= position.character;\n            }\n            return this.start.line <= position.line && this.end.line >= position.line;\n        };\n        this.start = start;\n        this.end = end;\n    }\n    setStart(line, character) {\n        this.start = new Position(line, character);\n    }\n    setEnd(line, character) {\n        this.end = new Position(line, character);\n    }\n}\nexport class Position {\n    constructor(line, character) {\n        this.lessThanOrEqualTo = (position) => this.line < position.line ||\n            (this.line === position.line && this.character <= position.character);\n        this.line = line;\n        this.character = character;\n    }\n    setLine(line) {\n        this.line = line;\n    }\n    setCharacter(character) {\n        this.character = character;\n    }\n}\nexport function offsetToPosition(text, loc) {\n    const EOL = '\\n';\n    const buf = text.slice(0, loc);\n    const lines = buf.split(EOL).length - 1;\n    const lastLineIndex = buf.lastIndexOf(EOL);\n    return new Position(lines, loc - lastLineIndex - 1);\n}\nexport function locToRange(text, loc) {\n    const start = offsetToPosition(text, loc.start);\n    const end = offsetToPosition(text, loc.end);\n    return new Range(start, end);\n}\n//# sourceMappingURL=Range.js.map","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  const oldSchema = context.getSchema();\n  const alreadyDefined =\n    (_ref =\n      (_ref2 =\n        (_oldSchema$astNode =\n          oldSchema === null || oldSchema === void 0\n            ? void 0\n            : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0\n          ? _oldSchema$astNode\n          : oldSchema === null || oldSchema === void 0\n          ? void 0\n          : oldSchema.getQueryType()) !== null && _ref2 !== void 0\n        ? _ref2\n        : oldSchema === null || oldSchema === void 0\n        ? void 0\n        : oldSchema.getMutationType()) !== null && _ref !== void 0\n      ? _ref\n      : oldSchema === null || oldSchema === void 0\n      ? void 0\n      : oldSchema.getSubscriptionType();\n  let schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(\n          new GraphQLError(\n            'Cannot define a new schema within a schema extension.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(\n          new GraphQLError('Must provide only one schema definition.', {\n            nodes: node,\n          }),\n        );\n      }\n\n      ++schemaDefinitionsCount;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  const schema = context.getSchema();\n  const definedOperationTypes = Object.create(null);\n  const existingOperationTypes = schema\n    ? {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n      }\n    : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes,\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // See: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const operationTypesNodes =\n      (_node$operationTypes = node.operationTypes) !== null &&\n      _node$operationTypes !== void 0\n        ? _node$operationTypes\n        : [];\n\n    for (const operationType of operationTypesNodes) {\n      const operation = operationType.operation;\n      const alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(\n          new GraphQLError(\n            `Type for ${operation} already defined in the schema. It cannot be redefined.`,\n            {\n              nodes: operationType,\n            },\n          ),\n        );\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one ${operation} type in schema.`,\n            {\n              nodes: [alreadyDefinedOperationType, operationType],\n            },\n          ),\n        );\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  const knownTypeNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName,\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(\n        new GraphQLError(\n          `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`,\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(\n        new GraphQLError(`There can be only one type named \"${typeName}\".`, {\n          nodes: [knownTypeNames[typeName], node.name],\n        }),\n      );\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isEnumType } from '../../type/definition.mjs';\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness,\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    const typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const valueNodes =\n      (_node$values = node.values) !== null && _node$values !== void 0\n        ? _node$values\n        : [];\n    const valueNames = knownValueNames[typeName];\n\n    for (const valueDef of valueNodes) {\n      const valueName = valueDef.name.value;\n      const existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: valueDef.name,\n            },\n          ),\n        );\n      } else if (valueNames[valueName]) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" can only be defined once.`,\n            {\n              nodes: [valueNames[valueName], valueDef.name],\n            },\n          ),\n        );\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_node$fields = node.fields) !== null && _node$fields !== void 0\n        ? _node$fields\n        : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: fieldDef.name,\n            },\n          ),\n        );\n      } else if (fieldNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" can only be defined once.`,\n            {\n              nodes: [fieldNames[fieldName], fieldDef.name],\n            },\n          ),\n        );\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  const knownDirectiveNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    DirectiveDefinition(node) {\n      const directiveName = node.name.value;\n\n      if (\n        schema !== null &&\n        schema !== void 0 &&\n        schema.getDirective(directiveName)\n      ) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${directiveName}\" already exists in the schema. It cannot be redefined.`,\n            {\n              nodes: node.name,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one directive named \"@${directiveName}\".`,\n            {\n              nodes: [knownDirectiveNames[directiveName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { Kind } from './kinds.mjs';\nexport function isDefinitionNode(node) {\n  return (\n    isExecutableDefinitionNode(node) ||\n    isTypeSystemDefinitionNode(node) ||\n    isTypeSystemExtensionNode(node)\n  );\n}\nexport function isExecutableDefinitionNode(node) {\n  return (\n    node.kind === Kind.OPERATION_DEFINITION ||\n    node.kind === Kind.FRAGMENT_DEFINITION\n  );\n}\nexport function isSelectionNode(node) {\n  return (\n    node.kind === Kind.FIELD ||\n    node.kind === Kind.FRAGMENT_SPREAD ||\n    node.kind === Kind.INLINE_FRAGMENT\n  );\n}\nexport function isValueNode(node) {\n  return (\n    node.kind === Kind.VARIABLE ||\n    node.kind === Kind.INT ||\n    node.kind === Kind.FLOAT ||\n    node.kind === Kind.STRING ||\n    node.kind === Kind.BOOLEAN ||\n    node.kind === Kind.NULL ||\n    node.kind === Kind.ENUM ||\n    node.kind === Kind.LIST ||\n    node.kind === Kind.OBJECT\n  );\n}\nexport function isConstValueNode(node) {\n  return (\n    isValueNode(node) &&\n    (node.kind === Kind.LIST\n      ? node.values.some(isConstValueNode)\n      : node.kind === Kind.OBJECT\n      ? node.fields.some((field) => isConstValueNode(field.value))\n      : node.kind !== Kind.VARIABLE)\n  );\n}\nexport function isTypeNode(node) {\n  return (\n    node.kind === Kind.NAMED_TYPE ||\n    node.kind === Kind.LIST_TYPE ||\n    node.kind === Kind.NON_NULL_TYPE\n  );\n}\nexport function isTypeSystemDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCHEMA_DEFINITION ||\n    isTypeDefinitionNode(node) ||\n    node.kind === Kind.DIRECTIVE_DEFINITION\n  );\n}\nexport function isTypeDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_DEFINITION ||\n    node.kind === Kind.OBJECT_TYPE_DEFINITION ||\n    node.kind === Kind.INTERFACE_TYPE_DEFINITION ||\n    node.kind === Kind.UNION_TYPE_DEFINITION ||\n    node.kind === Kind.ENUM_TYPE_DEFINITION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n  );\n}\nexport function isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nexport function isTypeExtensionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_EXTENSION ||\n    node.kind === Kind.OBJECT_TYPE_EXTENSION ||\n    node.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n    node.kind === Kind.UNION_TYPE_EXTENSION ||\n    node.kind === Kind.ENUM_TYPE_EXTENSION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION\n  );\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeSystemDefinitionNode,\n  isTypeSystemExtensionNode,\n} from '../../language/predicates.mjs';\nimport { introspectionTypes } from '../../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../../type/scalars.mjs';\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nexport function KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = suggestionList(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new GraphQLError(\n            `Unknown type \"${typeName}\".` + didYouMean(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\nconst standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(\n  (type) => type.name,\n);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value))\n  );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../../language/ast.mjs';\nimport { DirectiveLocation } from '../../language/directiveLocation.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\nexport function KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name) => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(\n          new GraphQLError(`Unknown directive \"@${name}\".`, {\n            nodes: node,\n          }),\n        );\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${name}\" may not be used on ${candidateLocation}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || invariant(false);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      'kind' in parentNode || invariant(false);\n      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n        ? DirectiveLocation.INPUT_FIELD_DEFINITION\n        : DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(appliedTo.kind));\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case OperationTypeNode.QUERY:\n      return DirectiveLocation.QUERY;\n\n    case OperationTypeNode.MUTATION:\n      return DirectiveLocation.MUTATION;\n\n    case OperationTypeNode.SUBSCRIPTION:\n      return DirectiveLocation.SUBSCRIPTION;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../../language/predicates.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  const uniqueDirectiveMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  const schemaDirectives = Object.create(null);\n  const typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter(node) {\n      if (!('directives' in node) || !node.directives) {\n        return;\n      }\n\n      let seenDirectives;\n\n      if (\n        node.kind === Kind.SCHEMA_DEFINITION ||\n        node.kind === Kind.SCHEMA_EXTENSION\n      ) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        const typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (const directive of node.directives) {\n        const directiveName = directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(\n              new GraphQLError(\n                `The directive \"@${directiveName}\" can only be used once at this location.`,\n                {\n                  nodes: [seenDirectives[directiveName], directive],\n                },\n              ),\n            );\n          } else {\n            seenDirectives[directiveName] = directive;\n          }\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n","/**\n * Groups array items into a Map, given a function to produce grouping key.\n */\nexport function groupBy(list, keyFn) {\n  const result = new Map();\n\n  for (const item of list) {\n    const key = keyFn(item);\n    const group = result.get(key);\n\n    if (group === undefined) {\n      result.set(key, [item]);\n    } else {\n      group.push(item);\n    }\n  }\n\n  return result;\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n */\nexport function UniqueArgumentNamesRule(context) {\n  return {\n    Field: checkArgUniqueness,\n    Directive: checkArgUniqueness,\n  };\n\n  function checkArgUniqueness(parentNode) {\n    var _parentNode$arguments;\n\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const argumentNodes =\n      (_parentNode$arguments = parentNode.arguments) !== null &&\n      _parentNode$arguments !== void 0\n        ? _parentNode$arguments\n        : [];\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one argument named \"${argName}\".`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n  }\n}\n","import { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Input-Object-Field-Uniqueness\n */\nexport function UniqueInputFieldNamesRule(context) {\n  const knownNameStack = [];\n  let knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n\n      leave() {\n        const prevKnownNames = knownNameStack.pop();\n        prevKnownNames || invariant(false);\n        knownNames = prevKnownNames;\n      },\n    },\n\n    ObjectField(node) {\n      const fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one input field named \"${fieldName}\".`,\n            {\n              nodes: [knownNames[fieldName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isExecutableDefinitionNode } from '../../language/predicates.mjs';\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n *\n * See https://spec.graphql.org/draft/#sec-Executable-Definitions\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document(node) {\n      for (const definition of node.definitions) {\n        if (!isExecutableDefinitionNode(definition)) {\n          const defName =\n            definition.kind === Kind.SCHEMA_DEFINITION ||\n            definition.kind === Kind.SCHEMA_EXTENSION\n              ? 'schema'\n              : '\"' + definition.name.value + '\"';\n          context.reportError(\n            new GraphQLError(`The ${defName} definition is not executable.`, {\n              nodes: definition,\n            }),\n          );\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n * See https://spec.graphql.org/draft/#sec-Directives-Are-In-Valid-Locations\n */\nexport function KnownArgumentNamesRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...KnownArgumentNamesOnDirectivesRule(context),\n\n    Argument(argNode) {\n      const argDef = context.getArgument();\n      const fieldDef = context.getFieldDef();\n      const parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        const argName = argNode.name.value;\n        const knownArgsNames = fieldDef.args.map((arg) => arg.name);\n        const suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(\n          new GraphQLError(\n            `Unknown argument \"${argName}\" on field \"${parentType.name}.${fieldDef.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: argNode,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  const directiveArgs = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argsNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);\n    }\n  }\n\n  return {\n    Directive(directiveNode) {\n      const directiveName = directiveNode.name.value;\n      const knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (const argNode of directiveNode.arguments) {\n          const argName = argNode.name.value;\n\n          if (!knownArgs.includes(argName)) {\n            const suggestions = suggestionList(argName, knownArgs);\n            context.reportError(\n              new GraphQLError(\n                `Unknown argument \"${argName}\" on directive \"@${directiveName}\".` +\n                  didYouMean(suggestions),\n                {\n                  nodes: argNode,\n                },\n              ),\n            );\n          }\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spread-target-defined\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread(node) {\n      const fragmentName = node.name.value;\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(\n          new GraphQLError(`Unknown fragment \"${fragmentName}\".`, {\n            nodes: node.name,\n          }),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-Must-Be-Used\n */\nexport function NoUnusedFragmentsRule(context) {\n  const operationDefs = [];\n  const fragmentDefs = [];\n  return {\n    OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n\n    FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n\n    Document: {\n      leave() {\n        const fragmentNameUsed = Object.create(null);\n\n        for (const operation of operationDefs) {\n          for (const fragment of context.getRecursivelyReferencedFragments(\n            operation,\n          )) {\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (const fragmentDef of fragmentDefs) {\n          const fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(\n              new GraphQLError(`Fragment \"${fragName}\" is never used.`, {\n                nodes: fragmentDef,\n              }),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n","import { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport { Kind } from '../language/kinds.mjs';\n/**\n * Sort ValueNode.\n *\n * This function returns a sorted copy of the given ValueNode.\n *\n * @internal\n */\n\nexport function sortValueNode(valueNode) {\n  switch (valueNode.kind) {\n    case Kind.OBJECT:\n      return { ...valueNode, fields: sortFields(valueNode.fields) };\n\n    case Kind.LIST:\n      return { ...valueNode, values: valueNode.values.map(sortValueNode) };\n\n    case Kind.INT:\n    case Kind.FLOAT:\n    case Kind.STRING:\n    case Kind.BOOLEAN:\n    case Kind.NULL:\n    case Kind.ENUM:\n    case Kind.VARIABLE:\n      return valueNode;\n  }\n}\n\nfunction sortFields(fields) {\n  return fields\n    .map((fieldNode) => ({\n      ...fieldNode,\n      value: sortValueNode(fieldNode.value),\n    }))\n    .sort((fieldA, fieldB) =>\n      naturalCompare(fieldA.name.value, fieldB.name.value),\n    );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (\n      comparedFragmentPairs.has(\n        referencedFragmentName,\n        fragmentName,\n        areMutuallyExclusive,\n      )\n    ) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(\n      referencedFragmentName,\n      fragmentName,\n      areMutuallyExclusive,\n    );\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments;\n\n  // FIXME https://github.com/graphql/graphql-js/issues/2203\n  const args =\n    /* c8 ignore next */\n    (_fieldNode$arguments = fieldNode.arguments) !== null &&\n    _fieldNode$arguments !== void 0\n      ? _fieldNode$arguments\n      : [];\n  const inputObjectWithArgs = {\n    kind: Kind.OBJECT,\n    fields: args.map((argNode) => ({\n      kind: Kind.OBJECT_FIELD,\n      name: argNode.name,\n      value: argNode.value,\n    })),\n  };\n  return print(sortValueNode(inputObjectWithArgs));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isRequiredArgument, isType } from '../../type/definition.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...ProvidedRequiredArgumentsOnDirectivesRule(context),\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        }\n\n        const providedArgs = new Set( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n          /* c8 ignore next */\n          (_fieldNode$arguments = fieldNode.arguments) === null ||\n          _fieldNode$arguments === void 0\n            ? void 0\n            : _fieldNode$arguments.map((arg) => arg.name.value),\n        );\n\n        for (const argDef of fieldDef.args) {\n          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {\n            const argTypeStr = inspect(argDef.type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldDef.name}\" argument \"${argDef.name}\" of type \"${argTypeStr}\" is required, but it was not provided.`,\n                {\n                  nodes: fieldNode,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var _schema$getDirectives;\n\n  const requiredArgsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives =\n    (_schema$getDirectives =\n      schema === null || schema === void 0\n        ? void 0\n        : schema.getDirectives()) !== null && _schema$getDirectives !== void 0\n      ? _schema$getDirectives\n      : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    requiredArgsMap[directive.name] = keyMap(\n      directive.args.filter(isRequiredArgument),\n      (arg) => arg.name,\n    );\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      requiredArgsMap[def.name.value] = keyMap(\n        argNodes.filter(isRequiredArgumentNode),\n        (arg) => arg.name.value,\n      );\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(directiveNode) {\n        const directiveName = directiveNode.name.value;\n        const requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n          /* c8 ignore next */\n          const argNodes =\n            (_directiveNode$argume = directiveNode.arguments) !== null &&\n            _directiveNode$argume !== void 0\n              ? _directiveNode$argume\n              : [];\n          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));\n\n          for (const [argName, argDef] of Object.entries(requiredArgs)) {\n            if (!argNodeMap.has(argName)) {\n              const argType = isType(argDef.type)\n                ? inspect(argDef.type)\n                : print(argDef.type);\n              context.reportError(\n                new GraphQLError(\n                  `Directive \"@${directiveName}\" argument \"${argName}\" of type \"${argType}\" is required, but it was not provided.`,\n                  {\n                    nodes: directiveNode,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { isInputType, isNonNullType } from '../type/definition.mjs';\nimport { coerceInputValue } from '../utilities/coerceInputValue.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { valueFromAST } from '../utilities/valueFromAST.mjs';\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors =\n    options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n\n        errors.push(error);\n      },\n    );\n\n    if (errors.length === 0) {\n      return {\n        coerced,\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors,\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = print(varDefNode.type);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`,\n          {\n            nodes: varDefNode.type,\n          },\n        ),\n      );\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if (isNonNullType(varType)) {\n        const varTypeStr = inspect(varType);\n        onError(\n          new GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            {\n              nodes: varDefNode,\n            },\n          ),\n        );\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && isNonNullType(varType)) {\n      const varTypeStr = inspect(varType);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          {\n            nodes: varDefNode,\n          },\n        ),\n      );\n      continue;\n    }\n\n    coercedValues[varName] = coerceInputValue(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${printPathArray(path)}\"`;\n        }\n\n        onError(\n          new GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error,\n          }),\n        );\n      },\n    );\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes =\n    (_node$arguments = node.arguments) !== null && _node$arguments !== void 0\n      ? _node$arguments\n      : [];\n  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\n          `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n            'was not provided.',\n          {\n            nodes: node,\n          },\n        );\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (\n        variableValues == null ||\n        !hasOwnProperty(variableValues, variableName)\n      ) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\n            `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            {\n              nodes: valueNode,\n            },\n          );\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\n        `Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` +\n          'must not be null.',\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        `Argument \"${name}\" has invalid value ${print(valueNode)}.`,\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode =\n    (_node$directives = node.directives) === null || _node$directives === void 0\n      ? void 0\n      : _node$directives.find(\n          (directive) => directive.name.value === directiveDef.name,\n        );\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport {\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n} from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(\n    GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  getNullableType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isRequiredInputField,\n} from '../../type/definition.mjs';\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          const typeStr = inspect(fieldDef.type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = getNamedType(context.getParentInputType());\n      const fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        const suggestions = suggestionList(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `Expected value of type \"${inspect(type)}\", found ${print(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    const typeStr = inspect(locationType);\n    context.reportError(\n      new GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = inspect(locationType);\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}; ` +\n            error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isNonNullType } from '../../type/definition.mjs';\nimport { isTypeSubTypeOf } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables in allowed position\n *\n * Variable usages must be compatible with the arguments they are passed to.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed\n */\nexport function VariablesInAllowedPositionRule(context) {\n  let varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        varDefMap = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node, type, defaultValue } of usages) {\n          const varName = node.name.value;\n          const varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            const schema = context.getSchema();\n            const varType = typeFromAST(schema, varDef.type);\n\n            if (\n              varType &&\n              !allowedVariableUsage(\n                schema,\n                varType,\n                varDef.defaultValue,\n                type,\n                defaultValue,\n              )\n            ) {\n              const varTypeStr = inspect(varType);\n              const typeStr = inspect(type);\n              context.reportError(\n                new GraphQLError(\n                  `Variable \"$${varName}\" of type \"${varTypeStr}\" used in position expecting type \"${typeStr}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    },\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(\n  schema,\n  varType,\n  varDefaultValue,\n  locationType,\n  locationDefaultValue,\n) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    const hasNonNullVariableDefaultValue =\n      varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    const hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    const nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n","// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from './rules/ExecutableDefinitionsRule.mjs'; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from './rules/FieldsOnCorrectTypeRule.mjs'; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from './rules/FragmentsOnCompositeTypesRule.mjs'; // Spec Section: \"Argument Names\"\n\nimport {\n  KnownArgumentNamesOnDirectivesRule,\n  KnownArgumentNamesRule,\n} from './rules/KnownArgumentNamesRule.mjs'; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from './rules/KnownDirectivesRule.mjs'; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from './rules/KnownFragmentNamesRule.mjs'; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from './rules/KnownTypeNamesRule.mjs'; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from './rules/LoneAnonymousOperationRule.mjs'; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from './rules/LoneSchemaDefinitionRule.mjs'; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from './rules/NoFragmentCyclesRule.mjs'; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from './rules/NoUndefinedVariablesRule.mjs'; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from './rules/NoUnusedFragmentsRule.mjs'; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from './rules/NoUnusedVariablesRule.mjs'; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from './rules/OverlappingFieldsCanBeMergedRule.mjs'; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from './rules/PossibleFragmentSpreadsRule.mjs';\nimport { PossibleTypeExtensionsRule } from './rules/PossibleTypeExtensionsRule.mjs'; // Spec Section: \"Argument Optionality\"\n\nimport {\n  ProvidedRequiredArgumentsOnDirectivesRule,\n  ProvidedRequiredArgumentsRule,\n} from './rules/ProvidedRequiredArgumentsRule.mjs'; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from './rules/ScalarLeafsRule.mjs'; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from './rules/SingleFieldSubscriptionsRule.mjs';\nimport { UniqueArgumentDefinitionNamesRule } from './rules/UniqueArgumentDefinitionNamesRule.mjs'; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from './rules/UniqueArgumentNamesRule.mjs';\nimport { UniqueDirectiveNamesRule } from './rules/UniqueDirectiveNamesRule.mjs'; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from './rules/UniqueDirectivesPerLocationRule.mjs';\nimport { UniqueEnumValueNamesRule } from './rules/UniqueEnumValueNamesRule.mjs';\nimport { UniqueFieldDefinitionNamesRule } from './rules/UniqueFieldDefinitionNamesRule.mjs'; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from './rules/UniqueFragmentNamesRule.mjs'; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from './rules/UniqueInputFieldNamesRule.mjs'; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from './rules/UniqueOperationNamesRule.mjs';\nimport { UniqueOperationTypesRule } from './rules/UniqueOperationTypesRule.mjs';\nimport { UniqueTypeNamesRule } from './rules/UniqueTypeNamesRule.mjs'; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from './rules/UniqueVariableNamesRule.mjs'; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from './rules/ValuesOfCorrectTypeRule.mjs'; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from './rules/VariablesAreInputTypesRule.mjs'; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from './rules/VariablesInAllowedPositionRule.mjs';\n\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\nexport const specifiedRules = Object.freeze([\n  ExecutableDefinitionsRule,\n  UniqueOperationNamesRule,\n  LoneAnonymousOperationRule,\n  SingleFieldSubscriptionsRule,\n  KnownTypeNamesRule,\n  FragmentsOnCompositeTypesRule,\n  VariablesAreInputTypesRule,\n  ScalarLeafsRule,\n  FieldsOnCorrectTypeRule,\n  UniqueFragmentNamesRule,\n  KnownFragmentNamesRule,\n  NoUnusedFragmentsRule,\n  PossibleFragmentSpreadsRule,\n  NoFragmentCyclesRule,\n  UniqueVariableNamesRule,\n  NoUndefinedVariablesRule,\n  NoUnusedVariablesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  KnownArgumentNamesRule,\n  UniqueArgumentNamesRule,\n  ValuesOfCorrectTypeRule,\n  ProvidedRequiredArgumentsRule,\n  VariablesInAllowedPositionRule,\n  OverlappingFieldsCanBeMergedRule,\n  UniqueInputFieldNamesRule,\n]);\n/**\n * @internal\n */\n\nexport const specifiedSDLRules = Object.freeze([\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueArgumentDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  KnownArgumentNamesOnDirectivesRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule,\n  ProvidedRequiredArgumentsOnDirectivesRule,\n]);\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Operation-Name-Uniqueness\n */\nexport function UniqueOperationNamesRule(context) {\n  const knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition(node) {\n      const operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one operation named \"${operationName.value}\".`,\n              {\n                nodes: [\n                  knownOperationNames[operationName.value],\n                  operationName,\n                ],\n              },\n            ),\n          );\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n\n    FragmentDefinition: () => false,\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n *\n * See https://spec.graphql.org/draft/#sec-Lone-Anonymous-Operation\n */\nexport function LoneAnonymousOperationRule(context) {\n  let operationCount = 0;\n  return {\n    Document(node) {\n      operationCount = node.definitions.filter(\n        (definition) => definition.kind === Kind.OPERATION_DEFINITION,\n      ).length;\n    },\n\n    OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(\n          new GraphQLError(\n            'This anonymous operation must be the only defined operation.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { collectFields } from '../../execution/collectFields.mjs';\n\n/**\n * Subscriptions must only include a non-introspection field.\n *\n * A GraphQL subscription is valid only if it contains a single root field and\n * that root field is not an introspection field.\n *\n * See https://spec.graphql.org/draft/#sec-Single-root-field\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        const schema = context.getSchema();\n        const subscriptionType = schema.getSubscriptionType();\n\n        if (subscriptionType) {\n          const operationName = node.name ? node.name.value : null;\n          const variableValues = Object.create(null);\n          const document = context.getDocument();\n          const fragments = Object.create(null);\n\n          for (const definition of document.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[definition.name.value] = definition;\n            }\n          }\n\n          const fields = collectFields(\n            schema,\n            fragments,\n            variableValues,\n            subscriptionType,\n            node.selectionSet,\n          );\n\n          if (fields.size > 1) {\n            const fieldSelectionLists = [...fields.values()];\n            const extraFieldSelectionLists = fieldSelectionLists.slice(1);\n            const extraFieldSelections = extraFieldSelectionLists.flat();\n            context.reportError(\n              new GraphQLError(\n                operationName != null\n                  ? `Subscription \"${operationName}\" must select only one top level field.`\n                  : 'Anonymous Subscription must select only one top level field.',\n                {\n                  nodes: extraFieldSelections,\n                },\n              ),\n            );\n          }\n\n          for (const fieldNodes of fields.values()) {\n            const field = fieldNodes[0];\n            const fieldName = field.name.value;\n\n            if (fieldName.startsWith('__')) {\n              context.reportError(\n                new GraphQLError(\n                  operationName != null\n                    ? `Subscription \"${operationName}\" must not select an introspection top level field.`\n                    : 'Anonymous Subscription must not select an introspection top level field.',\n                  {\n                    nodes: fieldNodes,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          const typeStr = print(typeCondition);\n          context.reportError(\n            new GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        const typeStr = print(node.typeCondition);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isInputType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n *\n * See https://spec.graphql.org/draft/#sec-Variables-Are-Input-Types\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.type);\n\n      if (type !== undefined && !isInputType(type)) {\n        const variableName = node.variable.name.value;\n        const typeName = print(node.type);\n        context.reportError(\n          new GraphQLError(\n            `Variable \"$${variableName}\" cannot be non-input type \"${typeName}\".`,\n            {\n              nodes: node.type,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { getNamedType, isLeafType } from '../../type/definition.mjs';\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field(node) {\n      const type = context.getType();\n      const selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            const fieldName = node.name.value;\n            const typeStr = inspect(type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldName}\" must not have a selection since type \"${typeStr}\" has no subfields.`,\n                {\n                  nodes: selectionSet,\n                },\n              ),\n            );\n          }\n        } else if (!selectionSet) {\n          const fieldName = node.name.value;\n          const typeStr = inspect(type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have a selection of subfields. Did you mean \"${fieldName} { ... }\"?`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { naturalCompare } from '../../jsutils/naturalCompare.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = didYouMean(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n        return -1;\n      }\n\n      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n        return 1;\n      }\n\n      return naturalCompare(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Name-Uniqueness\n */\nexport function UniqueFragmentNamesRule(context) {\n  const knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      const fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one fragment named \"${fragmentName}\".`,\n            {\n              nodes: [knownFragmentNames[fragmentName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { doTypesOverlap } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        isCompositeType(fragType) &&\n        isCompositeType(parentType) &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  return {\n    OperationDefinition(operationNode) {\n      var _operationNode$variab;\n\n      // See: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const variableDefinitions =\n        (_operationNode$variab = operationNode.variableDefinitions) !== null &&\n        _operationNode$variab !== void 0\n          ? _operationNode$variab\n          : [];\n      const seenVariableDefinitions = groupBy(\n        variableDefinitions,\n        (node) => node.variable.name.value,\n      );\n\n      for (const [variableName, variableNodes] of seenVariableDefinitions) {\n        if (variableNodes.length > 1) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one variable named \"$${variableName}\".`,\n              {\n                nodes: variableNodes.map((node) => node.variable.name),\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Uses-Defined\n */\nexport function NoUndefinedVariablesRule(context) {\n  let variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        variableNameDefined = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          const varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${varName}\" is not defined by operation \"${operation.name.value}\".`\n                  : `Variable \"$${varName}\" is not defined.`,\n                {\n                  nodes: [node, operation],\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variables-Used\n */\nexport function NoUnusedVariablesRule(context) {\n  let variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefs = [];\n      },\n\n      leave(operation) {\n        const variableNameUsed = Object.create(null);\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (const variableDef of variableDefs) {\n          const variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${variableName}\" is never used in operation \"${operation.name.value}\".`\n                  : `Variable \"$${variableName}\" is never used.`,\n                {\n                  nodes: variableDef,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(def) {\n      variableDefs.push(def);\n    },\n  };\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument definition names\n *\n * A GraphQL Object or Interface type is only valid if all its fields have uniquely named arguments.\n * A GraphQL Directive is only valid if all its arguments are uniquely named.\n */\nexport function UniqueArgumentDefinitionNamesRule(context) {\n  return {\n    DirectiveDefinition(directiveNode) {\n      var _directiveNode$argume;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argumentNodes =\n        (_directiveNode$argume = directiveNode.arguments) !== null &&\n        _directiveNode$argume !== void 0\n          ? _directiveNode$argume\n          : [];\n      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);\n    },\n\n    InterfaceTypeDefinition: checkArgUniquenessPerField,\n    InterfaceTypeExtension: checkArgUniquenessPerField,\n    ObjectTypeDefinition: checkArgUniquenessPerField,\n    ObjectTypeExtension: checkArgUniquenessPerField,\n  };\n\n  function checkArgUniquenessPerField(typeNode) {\n    var _typeNode$fields;\n\n    const typeName = typeNode.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_typeNode$fields = typeNode.fields) !== null &&\n      _typeNode$fields !== void 0\n        ? _typeNode$fields\n        : [];\n\n    for (const fieldDef of fieldNodes) {\n      var _fieldDef$arguments;\n\n      const fieldName = fieldDef.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n\n      const argumentNodes =\n        (_fieldDef$arguments = fieldDef.arguments) !== null &&\n        _fieldDef$arguments !== void 0\n          ? _fieldDef$arguments\n          : [];\n      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);\n    }\n\n    return false;\n  }\n\n  function checkArgUniqueness(parentName, argumentNodes) {\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `Argument \"${parentName}(${argName}:)\" can only be defined once.`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n\n    return false;\n  }\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport {\n  SDLValidationContext,\n  ValidationContext,\n} from './ValidationContext.mjs';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(\n  schema,\n  documentAST,\n  rules = specifiedRules,\n  options,\n  /** @deprecated will be removed in 17.0.0 */\n  typeInfo = new TypeInfo(schema),\n) {\n  var _options$maxErrors;\n\n  const maxErrors =\n    (_options$maxErrors =\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\n      null && _options$maxErrors !== void 0\n      ? _options$maxErrors\n      : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(\n    schema,\n    documentAST,\n    typeInfo,\n    (error) => {\n      if (errors.length >= maxErrors) {\n        errors.push(\n          new GraphQLError(\n            'Too many validation errors, error limit reached. Validation aborted.',\n          ),\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n        throw abortObj;\n      }\n\n      errors.push(error);\n    },\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map((rule) => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(\n  documentAST,\n  schemaToExtend,\n  rules = specifiedSDLRules,\n) {\n  const errors = [];\n  const context = new SDLValidationContext(\n    documentAST,\n    schemaToExtend,\n    (error) => {\n      errors.push(error);\n    },\n  );\n  const visitors = rules.map((rule) => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n","import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { specifiedRules, validate, NoUnusedFragmentsRule, KnownFragmentNamesRule, Kind, ExecutableDefinitionsRule, LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, } from 'graphql';\nconst specifiedSDLRules = [\n    LoneSchemaDefinitionRule,\n    UniqueOperationTypesRule,\n    UniqueTypeNamesRule,\n    UniqueEnumValueNamesRule,\n    UniqueFieldDefinitionNamesRule,\n    UniqueDirectiveNamesRule,\n    KnownTypeNamesRule,\n    KnownDirectivesRule,\n    UniqueDirectivesPerLocationRule,\n    PossibleTypeExtensionsRule,\n    UniqueArgumentNamesRule,\n    UniqueInputFieldNamesRule,\n];\nexport function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n    const rules = specifiedRules.filter(rule => {\n        if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n            return false;\n        }\n        if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n            return false;\n        }\n        return true;\n    });\n    if (customRules) {\n        Array.prototype.push.apply(rules, customRules);\n    }\n    if (isSchemaDocument) {\n        Array.prototype.push.apply(rules, specifiedSDLRules);\n    }\n    const errors = validate(schema, ast, rules);\n    return errors.filter(error => {\n        if (error.message.includes('Unknown directive') && error.nodes) {\n            const node = error.nodes[0];\n            if (node && node.kind === Kind.DIRECTIVE) {\n                const name = node.name.value;\n                if (name === 'arguments' || name === 'argumentDefinitions') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    });\n}\n//# sourceMappingURL=validateWithCustomRules.js.map","import { GraphQLError, print, validate, NoDeprecatedCustomRule, parse, } from 'graphql';\nimport { CharacterStream, onlineParser } from '../parser';\nimport { Range, validateWithCustomRules, Position } from '../utils';\nexport const SEVERITY = {\n    Error: 'Error',\n    Warning: 'Warning',\n    Information: 'Information',\n    Hint: 'Hint',\n};\nexport const DIAGNOSTIC_SEVERITY = {\n    [SEVERITY.Error]: 1,\n    [SEVERITY.Warning]: 2,\n    [SEVERITY.Information]: 3,\n    [SEVERITY.Hint]: 4,\n};\nconst invariant = (condition, message) => {\n    if (!condition) {\n        throw new Error(message);\n    }\n};\nexport function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n    var _a, _b;\n    let ast = null;\n    let fragments = '';\n    if (externalFragments) {\n        fragments =\n            typeof externalFragments === 'string'\n                ? externalFragments\n                : externalFragments.reduce((acc, node) => acc + print(node) + '\\n\\n', '');\n    }\n    const enhancedQuery = fragments ? `${query}\\n\\n${fragments}` : query;\n    try {\n        ast = parse(enhancedQuery);\n    }\n    catch (error) {\n        if (error instanceof GraphQLError) {\n            const range = getRange((_b = (_a = error.locations) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, enhancedQuery);\n            return [\n                {\n                    severity: DIAGNOSTIC_SEVERITY.Error,\n                    message: error.message,\n                    source: 'GraphQL: Syntax',\n                    range,\n                },\n            ];\n        }\n        throw error;\n    }\n    return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n    if (!schema) {\n        return [];\n    }\n    const validationErrorAnnotations = validateWithCustomRules(schema, ast, customRules, isRelayCompatMode).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation'));\n    const deprecationWarningAnnotations = validate(schema, ast, [\n        NoDeprecatedCustomRule,\n    ]).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation'));\n    return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction annotations(error, severity, type) {\n    if (!error.nodes) {\n        return [];\n    }\n    const highlightedNodes = [];\n    for (const [i, node] of error.nodes.entries()) {\n        const highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined\n            ? node.name\n            : 'variable' in node && node.variable !== undefined\n                ? node.variable\n                : node;\n        if (highlightNode) {\n            invariant(error.locations, 'GraphQL validation error requires locations.');\n            const loc = error.locations[i];\n            const highlightLoc = getLocation(highlightNode);\n            const end = loc.column + (highlightLoc.end - highlightLoc.start);\n            highlightedNodes.push({\n                source: `GraphQL: ${type}`,\n                message: error.message,\n                severity,\n                range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end)),\n            });\n        }\n    }\n    return highlightedNodes;\n}\nexport function getRange(location, queryText) {\n    const parser = onlineParser();\n    const state = parser.startState();\n    const lines = queryText.split('\\n');\n    invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n    let stream = null;\n    for (let i = 0; i < location.line; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            const style = parser.token(stream, state);\n            if (style === 'invalidchar') {\n                break;\n            }\n        }\n    }\n    invariant(stream, 'Expected Parser stream to be available.');\n    const line = location.line - 1;\n    const start = stream.getStartOfToken();\n    const end = stream.getCurrentPosition();\n    return new Range(new Position(line, start), new Position(line, end));\n}\nfunction getLocation(node) {\n    const typeCastedNode = node;\n    const location = typeCastedNode.loc;\n    invariant(location, 'Expected ASTNode to have a location.');\n    return location;\n}\n//# sourceMappingURL=getDiagnostics.js.map","import CodeMirror from 'codemirror';\nimport { getDiagnostics } from 'graphql-language-service';\nconst SEVERITY = ['error', 'warning', 'information', 'hint'];\nconst TYPE = {\n    'GraphQL: Validation': 'validation',\n    'GraphQL: Deprecation': 'deprecation',\n    'GraphQL: Syntax': 'syntax',\n};\nCodeMirror.registerHelper('lint', 'graphql', (text, options) => {\n    const { schema, validationRules, externalFragments } = options;\n    const rawResults = getDiagnostics(text, schema, validationRules, undefined, externalFragments);\n    const results = rawResults.map(error => ({\n        message: error.message,\n        severity: error.severity ? SEVERITY[error.severity - 1] : SEVERITY[0],\n        type: error.source ? TYPE[error.source] : undefined,\n        from: CodeMirror.Pos(error.range.start.line, error.range.start.character),\n        to: CodeMirror.Pos(error.range.end.line, error.range.end.character),\n    }));\n    return results;\n});\n//# sourceMappingURL=lint.js.map"],"names":["Range","start","end","_this","_classCallCheck","this","containsPosition","position","line","character","_createClass","key","value","Position","__name","_this2","lessThanOrEqualTo","LoneSchemaDefinitionRule","context","_ref","_ref2","_oldSchema$astNode","oldSchema","getSchema","alreadyDefined","astNode","getQueryType","getMutationType","getSubscriptionType","schemaDefinitionsCount","SchemaDefinition","node","reportError","GraphQLError","nodes","UniqueOperationTypesRule","schema","definedOperationTypes","Object","create","existingOperationTypes","query","mutation","subscription","checkOperationTypes","SchemaExtension","_node$operationTypes","_step","operationTypesNodes","operationTypes","_iterator","_createForOfIteratorHelper","s","n","done","operationType","operation","alreadyDefinedOperationType","concat","err","e","f","UniqueTypeNamesRule","knownTypeNames","ScalarTypeDefinition","checkTypeName","ObjectTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","InputObjectTypeDefinition","typeName","name","getType","UniqueEnumValueNamesRule","existingTypeMap","getTypeMap","knownValueNames","checkValueUniqueness","EnumTypeExtension","_node$values","valueNodes","values","valueNames","valueDef","valueName","existingType","isEnumType","getValue","UniqueFieldDefinitionNamesRule","knownFieldNames","checkFieldUniqueness","InputObjectTypeExtension","InterfaceTypeExtension","ObjectTypeExtension","_node$fields","fieldNodes","fields","fieldNames","fieldDef","fieldName","hasField","type","isObjectType","isInterfaceType","isInputObjectType","getFields","UniqueDirectiveNamesRule","knownDirectiveNames","DirectiveDefinition","directiveName","getDirective","isExecutableDefinitionNode","kind","Kind","OPERATION_DEFINITION","FRAGMENT_DEFINITION","isTypeSystemDefinitionNode","SCHEMA_DEFINITION","isTypeDefinitionNode","DIRECTIVE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","isTypeSystemExtensionNode","SCHEMA_EXTENSION","isTypeExtensionNode","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","KnownTypeNamesRule","existingTypesMap","definedTypes","getDocument","definitions","def","typeNames","_toConsumableArray","keys","NamedType","_1","parent","_2","ancestors","_ancestors$","definitionNode","isSDL","standardTypeNames","includes","suggestedTypes","suggestionList","didYouMean","specifiedScalarTypes","introspectionTypes","map","KnownDirectivesRule","locationsMap","definedDirectives","getDirectives","specifiedDirectives","directive","locations","_step2","astDefinitions","_iterator2","Directive","_key","_parent","_path","candidateLocation","appliedTo","length","invariant","OperationTypeNode","QUERY","DirectiveLocation","MUTATION","SUBSCRIPTION","getDirectiveLocationForOperation","FIELD","FRAGMENT_SPREAD","INLINE_FRAGMENT","VARIABLE_DEFINITION","SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","INTERFACE","UNION","ENUM","ENUM_VALUE_DEFINITION","ENUM_VALUE","INPUT_OBJECT","INPUT_VALUE_DEFINITION","parentNode","INPUT_FIELD_DEFINITION","ARGUMENT_DEFINITION","inspect","getDirectiveLocationForASTPath","UniqueDirectivesPerLocationRule","uniqueDirectiveMap","isRepeatable","repeatable","schemaDirectives","typeDirectivesMap","enter","directives","seenDirectives","undefined","_step3","_iterator3","PossibleTypeExtensionsRule","ScalarTypeExtension","checkExtension","UnionTypeExtension","expectedKind","defNode","defKindToExtKind","isScalarType","isUnionType","typeToExtKind","kindStr","extensionKindToTypeName","allTypeNames","_objectSpread","_defKindToExtKind","_defineProperty","groupBy","list","keyFn","result","Map","item","group","get","set","push","UniqueArgumentNamesRule","Field","checkArgUniqueness","_parentNode$arguments","seenArgs","arguments","arg","_step$value","_slicedToArray","argName","argNodes","UniqueInputFieldNamesRule","knownNameStack","knownNames","ObjectValue","leave","prevKnownNames","pop","ObjectField","ExecutableDefinitionsRule","Document","definition","defName","KnownArgumentNamesOnDirectivesRule","directiveArgs","args","_def$arguments","argsNodes","directiveNode","knownArgs","argNode","suggestions","KnownFragmentNamesRule","FragmentSpread","fragmentName","getFragment","NoUnusedFragmentsRule","operationDefs","fragmentDefs","OperationDefinition","FragmentDefinition","fragmentNameUsed","_i","_operationDefs","getRecursivelyReferencedFragments","_i2","_fragmentDefs","fragmentDef","fragName","sortValueNode","valueNode","fieldNode","sort","fieldA","fieldB","naturalCompare","LIST","INT","FLOAT","STRING","BOOLEAN","NULL","VARIABLE","reasonMessage","reason","Array","isArray","responseName","subReason","join","collectConflictsBetweenFieldsAndFragment","conflicts","cachedFieldsAndFragmentNames","comparedFragmentPairs","areMutuallyExclusive","fieldMap","fragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","_getReferencedFieldsA2","fieldMap2","referencedFragmentNames","collectConflictsBetween","referencedFragmentName","has","add","collectConflictsBetweenFragments","fragmentName1","fragmentName2","fragment1","fragment2","_getReferencedFieldsA3","_getReferencedFieldsA4","fieldMap1","referencedFragmentNames1","_getReferencedFieldsA5","_getReferencedFieldsA6","referencedFragmentNames2","_step4","_iterator4","parentFieldsAreMutuallyExclusive","_Object$entries2","entries","_Object$entries2$_i","fields1","fields2","_step9","_iterator9","_step10","field1","_iterator10","conflict","findConflict","field2","_field","parentType1","node1","def1","_field2","parentType2","node2","def2","name1","name2","stringifyArguments","type1","type2","doTypesConflict","selectionSet1","selectionSet","selectionSet2","_getFieldsAndFragment3","getFieldsAndFragmentNames","_getFieldsAndFragment4","fragmentNames1","_getFieldsAndFragment5","_getFieldsAndFragment6","fragmentNames2","_step5","_iterator5","_step6","_iterator6","_step7","_iterator7","_step8","_iterator8","findConflictsBetweenSubSelectionSets","getNamedType","_ref3","_ref5","flat","_ref7","subfieldConflicts","_fieldNode$arguments","inputObjectWithArgs","OBJECT_FIELD","print","isListType","ofType","isNonNullType","isLeafType","parentType","cached","nodeAndDefs","fragmentNames","_collectFieldsAndFragmentNames","fragmentType","typeFromAST","typeCondition","_step11","_iterator11","selections","selection","alias","inlineFragmentType","PairSet","_data","a","b","_this$_data$get","_ref9","_ref10","key1","key2","_ref11","_ref12","ProvidedRequiredArgumentsOnDirectivesRule","_schema$getDirectives","requiredArgsMap","keyMap","filter","isRequiredArgument","isRequiredArgumentNode","requiredArgs","_directiveNode$argume","argNodeMap","Set","_Object$entries","_Object$entries$_i","argDef","argType","isType","NON_NULL_TYPE","defaultValue","getDirectiveValues","directiveDef","variableValues","_node$directives","find","_node$arguments","coercedValues","argumentNodes","argumentNode","isNull","variableName","hasOwnProperty","coercedValue","valueFromAST","getArgumentValues","obj","prop","prototype","call","collectFieldsImpl","fragments","runtimeType","visitedFragmentNames","shouldIncludeNode","fieldList","doesFragmentConditionMatch","skip","GraphQLSkipDirective","if","include","GraphQLIncludeDirective","typeConditionNode","conditionalType","isAbstractType","isSubType","isValidValueNode","locationType","getInputType","parseLiteral","typeStr","error","message","originalError","allowedVariableUsage","varType","varDefaultValue","locationDefaultValue","nullableLocationType","isTypeSubTypeOf","specifiedRules","freeze","knownOperationNames","operationName","operationCount","subscriptionType","document","collectFields","size","extraFieldSelections","slice","startsWith","InlineFragment","isCompositeType","VariableDefinition","isInputType","variable","getParentType","getFieldDef","suggestion","usageCount","getPossibleTypes","possibleType","getInterfaces","_usageCount$possibleI","possibleInterface","typeA","typeB","usageCountDiff","x","getSuggestedTypeNames","possibleFieldNames","getSuggestedFieldNames","knownFragmentNames","fragType","doTypesOverlap","parentTypeStr","fragTypeStr","frag","getFragmentType","visitedFrags","spreadPath","spreadPathIndexByName","detectCycleRecursive","spreadNodes","getFragmentSpreads","spreadNode","spreadName","cycleIndex","spreadFragment","cyclePath","viaPath","operationNode","_operationNode$variab","seenVariableDefinitions","variableDefinitions","variableNodes","variableNameDefined","usages","getRecursiveVariableUsages","varName","variableDefs","variableNameUsed","_variableDefs","variableDef","Argument","getArgument","knownArgsNames","ListValue","getNullableType","getParentInputType","fieldNodeMap","field","_Object$values","isRequiredInputField","NullValue","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","providedArgs","argTypeStr","varDefMap","varDef","varTypeStr","SelectionSet","_getFieldsAndFragment","_getFieldsAndFragment2","i","j","collectConflictsWithin","findConflictsWithinSelectionSet","_step$value$","reasonMsg","checkArgUniquenessPerField","typeNode","_typeNode$fields","_fieldDef$arguments","parentName","_step2$value","ASTValidationContext","_Symbol$toStringTag","ast","onError","_ast","_fragments","_fragmentSpreads","_recursivelyReferencedFragments","_onError","spreads","setsToVisit","collectedNames","nodesToVisit","Symbol","toStringTag","ValidationContext","_ASTValidationContext2","_Symbol$toStringTag3","_inherits","_super2","_createSuper","typeInfo","_schema","_typeInfo","_variableUsages","_recursiveVariableUsages","newUsages","TypeInfo","visit","visitWithTypeInfo","Variable","getDefaultValue","getVariableUsages","getEnumValue","validate","documentAST","_options$maxErrors","rules","options","maxErrors","devAssert","assertValidSchema","abortObj","errors","visitor","visitInParallel","rule","NoDeprecatedCustomRule","deprecationReason","inputObjectDef","inputFieldDef","enumValueDef","enumTypeDef","specifiedSDLRules","validateWithCustomRules","customRules","isRelayCompatMode","isSchemaDocument","apply","DIRECTIVE","SEVERITY$1","DIAGNOSTIC_SEVERITY","_DIAGNOSTIC_SEVERITY","condition","Error","getDiagnostics","_a","_b","externalFragments","reduce","acc","enhancedQuery","parse","range","getRange","column","severity","source","validateQuery","validationErrorAnnotations","flatMap","annotations","deprecationWarningAnnotations","Warning","highlightedNodes","highlightNode","loc","highlightLoc","getLocation","location","queryText","parser","onlineParser","state","startState","lines","split","stream","CharacterStream","eol","token","getStartOfToken","getCurrentPosition","SEVERITY","TYPE","CodeMirror","registerHelper","text","validationRules","from","Pos","to"],"sourceRoot":""}